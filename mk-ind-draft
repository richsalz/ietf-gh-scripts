#! /usr/bin/env python3
"""
Create an IETF WG repository for an I-D
"""

import argparse
import os
import os.path
import shutil
import subprocess
import sys
import ietf_gh_utils as UTILS

# Parse command line.
parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument('--doc', '-d', metavar='DOCNAME', required=True)
parser.add_argument('--asis', '-a', action='store_true',
                    help="Don't try to standardize the name")
parser.add_argument('--default-branch', '-b', action='store', default='master',
                    help="Name the primary branch in the repository")
UTILS.add_gh_auth_arguments(parser)
args = parser.parse_args(sys.argv[1:])

if shutil.which("kramdown-rfc2629") is None:
    sys.exit("Error: Please install kramdown-rfc2629 as described in " +
             "https://github.com/martinthomson/i-d-template/blob/master/doc/SETUP.md")

DOCNAME = args.doc
ASIS = args.asis

# Login
G,USER = UTILS.gh_login(args)

# For individual draft, the WGNAME is the USER name
WGNAME = USER
EDITORS = [ USER ]

# Fix doc name: remove draft- ietf- $WGNAME- from front
if not ASIS:
    while True:
        for prefix in ( 'draft-', 'ietf-', WGNAME+'-'):
            found = False
            if DOCNAME.startswith(prefix):
                DOCNAME = DOCNAME[len(prefix):]
                found = True
        if not found:
            break
    if len(DOCNAME) == 0:
        raise SystemExit("Docname is all prefixes!")

# Verify user names
if not UTILS.verify_users(G, EDITORS):
    raise SystemExit("Missing GH accounts")

# See if organization exists.
WGNAME = UTILS.fix_wg_name(WGNAME)
DOC="draft-" + WGNAME + "-" + DOCNAME
ORG = USER
#if not UTILS.org_exists(G, ORG):
#    raise SystemExit("Organization not found; try mk-ietf-wg")
#o = G.get_organization(ORG)

# Create an editors team and populate it
#editors = o.create_team(DOC, privacy='closed')
#editors.add_membership(G.get_user(USER))
#done = [ USER ]
#for e in EDITORS:
#    if e not in done:
#        editors.add_membership(G.get_user(e))
#        done += [ e ]
# Add the "owners" people?

if os.path.lexists(DOC):
    sys.exit("Error: destination path '{}' already exists.".format(DOC))

# Create repository draft-$WGNAME-$DOCNAME
u = G.get_user()
repo = u.create_repo(DOC,
        description="Repository for " + DOC + " draft",
        )

# Remove pre-populated labels, add ours.
for label in repo.get_labels():
    label.delete()
repo.create_label("editorial", "41d366")
repo.create_label("design", "1d76db")
repo.create_label("parked", "f9d0c4")

TEMPLATE_DIR = os.path.abspath(os.path.dirname(__file__))

def write_contributing(vars):
    """Creates a CONTRIBUTING.md from a template and returns its filename."""
    filename = "CONTRIBUTING.md"
    with open("CONTRIBUTING.md", "w") as F:
        text = open(os.path.join(TEMPLATE_DIR, "contributing.txt")).read()
        F.write(text % vars)
    return filename


def write_initial_draft(vars):
    """Creates an initial I-D from a template and returns its filename."""
    filename = "draft-%(WGNAME)s-%(DOCNAME)s.md" % vars
    with open(filename, "w") as F:
        F.write("""---
docname: draft-%(WGNAME)s-%(DOCNAME)s-latest
title: The %(DOCNAME)s draft
date: {DATE}

workgroup: %(WGNAME)s
keyword: Internet-Draft

stand_alone: yes
pi: [toc, sortrefs, symrefs]

--- abstract

Content here.
""" % vars)
    return filename


subprocess.run(["git", "clone", "git@github.com:{}/{}".format(WGNAME, DOC)],
               check=True)
os.chdir(DOC)
subprocess.run(["git", "checkout", "--orphan", args.default_branch],
               check=True)
subprocess.run(["git", "add", write_contributing(vars()), write_initial_draft(vars())],
               check=True)
subprocess.run(["git", "commit", "-m", "Initial docs"],
               check=True)
subprocess.run(["git", "push", "--set-upstream", "origin", args.default_branch],
               check=True)
subprocess.run(["git", "clone", "https://github.com/martinthomson/i-d-template", "lib"],
               check=True)
subprocess.run(["make", "-f", "lib/setup.mk"],
               check=True)
subprocess.run(["git", "push"],
               check=True)
